#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Programista – FULL, na sztywno.
Brak zmiennych środowiskowych, brak whitelist. Jedyne zabezpieczenie: confirm=True.
"""

from __future__ import annotations
import os, shlex, subprocess, time, json, pathlib, textwrap, shutil, zipfile, tarfile, re, hashlib
from dataclasses import dataclass, asdict
from typing import Any, Dict, List, Optional

SHELL_TIMEOUT = 120
ROOT_DEFAULT = "."

@dataclass
class ExecResult:
    code: int
    stdout: str
    stderr: str
    cmd: str
    cwd: str
    took: float

def _run(cmd: str, cwd: Optional[str]=None, timeout: float=SHELL_TIMEOUT, shell: bool=False) -> ExecResult:
    t0 = time.time()
    try:
        if shell:
            p = subprocess.run(cmd, cwd=cwd, capture_output=True, text=True, timeout=timeout, shell=True)
        else:
            p = subprocess.run(shlex.split(cmd), cwd=cwd, capture_output=True, text=True, timeout=timeout)
        return ExecResult(p.returncode, p.stdout, p.stderr, cmd, cwd or os.getcwd(), time.time()-t0)
    except Exception as e:
        return ExecResult(125, "", str(e), cmd, cwd or os.getcwd(), time.time()-t0)

def _abspath(root: str, *parts: str) -> str:
    return os.path.abspath(os.path.join(root, *parts))

def _write(path: str, content: str) -> None:
    pathlib.Path(os.path.dirname(path)).mkdir(parents=True, exist_ok=True)
    pathlib.Path(path).write_text(content, encoding="utf-8")

def _read(path: str) -> str:
    return pathlib.Path(path).read_text(encoding="utf-8")

def _exists(path: str) -> bool:
    return pathlib.Path(path).exists()

def _sha256_file(path: str) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(1<<20), b""):
            h.update(chunk)
    return h.hexdigest()

class Programista:
    def __init__(self, root: str=ROOT_DEFAULT):
        self.root = os.path.abspath(root)
        pathlib.Path(self.root).mkdir(parents=True, exist_ok=True)

    # ===== Shell =====
    def exec(self, cmd: str, cwd: Optional[str]=None, timeout: Optional[float]=None,
             confirm: bool=False, dry_run: bool=False, shell: bool=False) -> Dict[str,Any]:
        if not confirm and not dry_run:
            return {"ok": False, "error": "confirm_required"}
        if dry_run:
            return {"ok": True, "dry_run": True, "cmd": cmd, "cwd": cwd or self.root}
        r = _run(cmd, cwd=cwd or self.root, timeout=timeout or SHELL_TIMEOUT, shell=shell)
        return {"ok": r.code==0, "exec": asdict(r)}

    # ===== Meta =====
    def snapshot(self) -> Dict[str, Any]:
        return {
            "root": self.root,
            "time": time.time(),
            "tools": {b: (shutil.which(b) is not None) for b in
                      ["python","python3","pip","pytest","ruff","flake8","black","isort","mypy","coverage",
                       "node","npm","yarn","pnpm","eslint","prettier","git","docker"]}
        }

    # ===== Plan =====
    def plan(self, goal: str, stack: str="python") -> Dict[str, Any]:
        g = goal.strip()
        if stack.lower().startswith("py"):
            steps = ["spec","project_init:py","deps","impl","qa:ruff/black/mypy/pytest","dockerize","git:commit"]
            artifacts = ["pyproject.toml","src/","tests/","README.md"]
        else:
            steps = ["spec","project_init:js","deps","impl","qa:eslint/test","dockerize","git:commit"]
            artifacts = ["package.json","src/","tests/","README.md"]
        return {"ok": True, "goal": g, "stack": stack, "steps": steps, "artifacts": artifacts}

    # ===== Project scaffold =====
    def project_init(self, name: str, kind: str="py-lib") -> Dict[str,Any]:
        proj = pathlib.Path(self.root)/name
        proj.mkdir(parents=True, exist_ok=True)
        (proj/"src").mkdir(exist_ok=True)
        (proj/"tests").mkdir(exist_ok=True)
        _write(str(proj/"README.md"), f"# {name}\nGenerated by Programista.\n")
        if kind in ("py-lib","py-cli","py-api"):
            _write(str(proj/"src/__init__.py"), "__version__='0.0.1'\n")
            if kind == "py-cli":
                _write(str(proj/"src/cli.py"), "def main():\n    import sys\n    print('CLI:', ' '.join(sys.argv[1:]))\n")
            if kind == "py-api":
                _write(str(proj/"src/api.py"), "from fastapi import FastAPI\napp=FastAPI()\n@app.get('/health')\ndef health(): return {'ok':True}\n")
            _write(str(proj/"pyproject.toml"), textwrap.dedent(f"""
                [project]
                name = "{name}"
                version = "0.0.1"
                requires-python = ">=3.10"
                dependencies = []
                [tool.pytest.ini_options]
                pythonpath = ["src"]
            """).strip()+"\n")
            _write(str(proj/"tests/test_basic.py"), "def test_ok():\n    assert 1+1==2\n")
        elif kind in ("js-lib","js-cli","js-api"):
            pkg = {"name":name,"version":"0.0.1","type":"module","scripts":{"test":"node -e \"process.exit(0)\""}}
            _write(str(proj/"package.json"), json.dumps(pkg, ensure_ascii=False, indent=2))
            _write(str(proj/"src/index.js"), "export const ok=()=>true;\n")
            _write(str(proj/"tests/basic.test.js"), "console.log('ok')\n")
        else:
            return {"ok": False, "error": "unknown_kind"}
        return {"ok": True, "project": str(proj)}

    # ===== Venv =====
    def venv_create(self, project: str, confirm: bool=False, dry_run: bool=False) -> Dict[str,Any]:
        proj = _abspath(self.root, project)
        py = shutil.which("python3") or shutil.which("python")
        if not py: return {"ok": False, "error":"python_not_found"}
        return self.exec(f"{py} -m venv .venv", cwd=proj, confirm=confirm, dry_run=dry_run)

    def venv_exec(self, project: str, cmd: str, confirm: bool=False, dry_run: bool=False) -> Dict[str,Any]:
        proj = _abspath(self.root, project)
        bin_dir = "Scripts" if os.name=="nt" else "bin"
        vbin = os.path.join(proj, ".venv", bin_dir)
        if not os.path.isdir(vbin): return {"ok": False, "error":"venv_missing"}
        parts = shlex.split(cmd)
        parts[0] = os.path.join(vbin, parts[0])
        return self.exec(" ".join(shlex.quote(p) for p in parts), cwd=proj, confirm=confirm, dry_run=dry_run)

    # ===== Deps =====
    def deps_add(self, project: str, pkgs: List[str], tool: str="pip", confirm: bool=False, dry_run: bool=False) -> Dict[str,Any]:
        proj = _abspath(self.root, project)
        pkgs = [p.strip() for p in pkgs if p.strip()]
        if not pkgs: return {"ok": False, "error":"empty_pkgs"}
        if tool == "pip": cmd = "pip install " + " ".join(shlex.quote(p) for p in pkgs)
        elif tool in ("npm","yarn","pnpm"): cmd = tool + " add " + " ".join(shlex.quote(p) for p in pkgs)
        else: return {"ok": False, "error":"unknown_tool"}
        return self.exec(cmd, cwd=proj, confirm=confirm, dry_run=dry_run)

    # ===== QA / Format / Test =====
    def qa(self, project: str, checks: List[str], confirm: bool=False, dry_run: bool=False) -> Dict[str,Any]:
        proj = _abspath(self.root, project)
        out: Dict[str,Any] = {}
        for c in checks:
            if c=="ruff": out["ruff"] = self.exec("ruff .", cwd=proj, confirm=confirm, dry_run=dry_run)
            elif c=="flake8": out["flake8"] = self.exec("flake8 .", cwd=proj, confirm=confirm, dry_run=dry_run)
            elif c=="black": out["black"] = self.exec("black --check .", cwd=proj, confirm=confirm, dry_run=dry_run)
            elif c=="mypy": out["mypy"] = self.exec("mypy .", cwd=proj, confirm=confirm, dry_run=dry_run)
            elif c=="pytest": out["pytest"] = self.exec("pytest -q", cwd=proj, confirm=confirm, dry_run=dry_run)
            elif c=="coverage": out["coverage"] = self.exec("coverage run -m pytest -q && coverage report -m", cwd=proj, confirm=confirm, dry_run=dry_run, shell=True)
            else: out[c] = {"skipped":"unknown_check"}
        return {"ok": True, "results": out}

    def format(self, project: str, tools: List[str], confirm: bool=False, dry_run: bool=False) -> Dict[str,Any]:
        proj = _abspath(self.root, project)
        out: Dict[str,Any] = {}
        for t in tools:
            if t=="black": out["black"] = self.exec("black .", cwd=proj, confirm=confirm, dry_run=dry_run)
            elif t=="isort": out["isort"] = self.exec("isort .", cwd=proj, confirm=confirm, dry_run=dry_run)
            elif t=="prettier": out["prettier"] = self.exec("prettier -w .", cwd=proj, confirm=confirm, dry_run=dry_run)
            else: out[t] = {"skipped":"unknown_tool"}
        return {"ok": True, "results": out}

    def test(self, project: str, confirm: bool=False, dry_run: bool=False) -> Dict[str,Any]:
        return self.qa(project, ["pytest"], confirm=confirm, dry_run=dry_run)

    # ===== Git =====
    def git_init(self, project: str, confirm: bool=False, dry_run: bool=False) -> Dict[str,Any]:
        proj = _abspath(self.root, project)
        os.makedirs(proj, exist_ok=True)
        _write(os.path.join(proj, ".gitignore"), textwrap.dedent("""
__pycache__/
.venv/
node_modules/
dist/
build/
.DS_Store
""").lstrip())
        r1 = self.exec("git init", cwd=proj, confirm=confirm, dry_run=dry_run)
        if not r1.get("ok"): return r1
        self.exec("git add .", cwd=proj, confirm=confirm, dry_run=dry_run)
        return self.exec('git commit -m "init"', cwd=proj, confirm=confirm, dry_run=dry_run)

    def git(self, project: str, args: str, confirm: bool=False, dry_run: bool=False) -> Dict[str,Any]:
        proj = _abspath(self.root, project)
        return self.exec("git " + args, cwd=proj, confirm=confirm, dry_run=dry_run)

    # ===== Docker =====
    def dockerize(self, project: str, kind: str="py") -> Dict[str,Any]:
        proj = _abspath(self.root, project)
        if kind=="py":
            df = """FROM python:3.12-slim
WORKDIR /app
COPY . /app
RUN pip install --no-cache-dir -r requirements.txt || true
EXPOSE 8080
CMD ["python","-m","http.server","8080"]
"""
        elif kind=="js":
            df = """FROM node:22-alpine
WORKDIR /app
COPY . /app
RUN npm ci || npm install
EXPOSE 8080
CMD ["node","src/index.js"]
"""
        else:
            return {"ok": False, "error":"unknown_kind"}
        _write(os.path.join(proj, "Dockerfile"), df)
        _write(os.path.join(proj, "docker-compose.yml"), "services:\n  app:\n    build: .\n    ports: [\"8080:8080\"]\n")
        return {"ok": True, "files":["Dockerfile","docker-compose.yml"]}

    def docker(self, project: str, args: str, confirm: bool=False, dry_run: bool=False) -> Dict[str,Any]:
        proj = _abspath(self.root, project)
        return self.exec("docker " + args, cwd=proj, confirm=confirm, dry_run=dry_run)

    # ===== Makefile =====
    def makefile(self, project: str, content: Optional[str]=None) -> Dict[str,Any]:
        proj = _abspath(self.root, project)
        default = ".PHONY: lint test format\nlint:\n\t@ruff . || true\n\t@flake8 . || true\ntest:\n\t@pytest -q || true\nformat:\n\t@black . || true\n"
        _write(os.path.join(proj, "Makefile"), content or default)
        return {"ok": True, "file":"Makefile"}

    # ===== Pliki / wyszukiwanie =====
    def write_file(self, path: str, content: str) -> Dict[str,Any]:
        abs_path = _abspath(self.root, path); _write(abs_path, content)
        return {"ok": True, "path": abs_path, "bytes": len(content.encode("utf-8"))}

    def read_file(self, path: str) -> Dict[str,Any]:
        abs_path = _abspath(self.root, path)
        if not _exists(abs_path): return {"ok": False, "error":"not_found"}
        return {"ok": True, "path": abs_path, "content": _read(abs_path)}

    def append_file(self, path: str, content: str) -> Dict[str,Any]:
        abs_path = _abspath(self.root, path)
        pathlib.Path(os.path.dirname(abs_path)).mkdir(parents=True, exist_ok=True)
        with open(abs_path, "a", encoding="utf-8") as f: f.write(content)
        return {"ok": True, "path": abs_path, "bytes": len(content.encode("utf-8"))}

    def replace_in_file(self, path: str, pattern: str, repl: str, flags: int=re.M) -> Dict[str,Any]:
        abs_path = _abspath(self.root, path)
        if not _exists(abs_path): return {"ok": False, "error":"not_found"}
        s = _read(abs_path); s2, n = re.subn(pattern, repl, s, flags=flags); _write(abs_path, s2)
        return {"ok": True, "replaced": n}

    def search(self, path: str, pattern: str, flags: int=re.I) -> Dict[str,Any]:
        abs_path = _abspath(self.root, path); out=[]
        for base, _, files in os.walk(abs_path):
            for f in files:
                p = os.path.join(base, f)
                try: txt = _read(p)
                except Exception: continue
                hits = [m.span() for m in re.finditer(pattern, txt, flags)]
                if hits: out.append({"file": p, "hits": len(hits)})
        return {"ok": True, "matches": out}

    def tree(self, path: str=".", max_depth: int=4) -> Dict[str,Any]:
        abs_path = _abspath(self.root, path); entries=[]
        for root, dirs, files in os.walk(abs_path):
            depth = root[len(abs_path):].count(os.sep)
            if depth > max_depth:
                dirs[:] = []
                continue
            rel = "." if root == abs_path else os.path.relpath(root, abs_path)
            entries.append(rel + "/")
            for f in sorted(files):
                entries.append(os.path.join(rel, f))
        return {"ok": True, "entries": entries}

    def zip(self, path: str, outzip: str) -> Dict[str,Any]:
        src = _abspath(self.root, path)
        outp = _abspath(self.root, outzip)
        with zipfile.ZipFile(outp, "w", zipfile.ZIP_DEFLATED) as z:
            for base, _, files in os.walk(src):
                for f in files:
                    p = os.path.join(base, f)
                    z.write(p, os.path.relpath(p, src))
        return {"ok": True, "zip": outp}

    def tar(self, path: str, outtar: str) -> Dict[str,Any]:
        src = _abspath(self.root, path)
        outp = _abspath(self.root, outtar)
        with tarfile.open(outp, "w:gz") as t:
            t.add(src, arcname=os.path.basename(src))
        return {"ok": True, "tar": outp}

    def checksum(self, path: str) -> Dict[str,Any]:
        abs_path = _abspath(self.root, path)
        if not _exists(abs_path):
            return {"ok": False, "error": "not_found"}
        return {"ok": True, "path": abs_path, "sha256": _sha256_file(abs_path)}

    def bench(self, cmd: str, repeats: int = 3, confirm: bool=False, dry_run: bool=False) -> Dict[str,Any]:
        if not confirm and not dry_run:
            return {"ok": False, "error": "confirm_required"}
        if dry_run:
            return {"ok": True, "dry_run": True, "cmd": cmd}
        times = []
        last = None
        for _ in range(max(1, repeats)):
            r = _run(cmd, cwd=self.root, timeout=SHELL_TIMEOUT, shell=False)
            times.append(r.took)
            last = r
        return {
            "ok": last.code == 0 if last else False,
            "min": min(times) if times else None,
            "max": max(times) if times else None,
            "avg": sum(times)/len(times) if times else None,
            "last": asdict(last) if last else None
        }
